diff --git a/src/java/com/android/internal/telephony/PhoneBase.java b/src/java/com/android/internal/telephony/PhoneBase.java
index d244ed6..4274a1e 100644
--- a/src/java/com/android/internal/telephony/PhoneBase.java
+++ b/src/java/com/android/internal/telephony/PhoneBase.java
@@ -31,6 +31,7 @@ import android.os.Message;
 import android.os.RegistrantList;
 import android.os.SystemProperties;
 import android.preference.PreferenceManager;
+import android.privacy.utilities.PrivacyDebugger;
 import android.provider.Settings;
 import android.telephony.CellInfo;
 import android.telephony.ServiceState;
@@ -288,7 +289,7 @@ public abstract class PhoneBase extends Handler implements Phone {
         mDataConnectionTracker = null;
         mUiccController = null;
     }
-
+    
     /**
      * When overridden the derived class needs to call
      * super.handleMessage(msg) so this method has a
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 8f8dfc7..9f4f40e 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -24,16 +24,25 @@ import android.telephony.TelephonyManager;
 import android.util.Log;
 import android.os.SystemProperties;
 
-import com.android.internal.telephony.cdma.CDMAPhone;
-import com.android.internal.telephony.cdma.CDMALTEPhone;
+//import com.android.internal.telephony.cdma.CDMAPhone;
+//mport com.android.internal.telephony.cdma.CDMALTEPhone;
 import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
-import com.android.internal.telephony.gsm.GSMPhone;
+//import com.android.internal.telephony.gsm.GSMPhone;
 import com.android.internal.telephony.sip.SipPhone;
 import com.android.internal.telephony.sip.SipPhoneFactory;
 import com.android.internal.telephony.uicc.UiccController;
 
 import java.lang.reflect.Constructor;
 
+//--------------------------------------------------------
+import android.privacy.surrogate.PrivacyCDMAPhone;
+import android.privacy.surrogate.PrivacyCDMALTEPhone;
+import android.privacy.surrogate.PrivacyGSMPhone;
+import android.privacy.surrogate.PrivacySipPhone;
+import android.privacy.surrogate.PrivacyPhoneProxy;
+import android.privacy.utilities.PrivacyDebugger;
+//--------------------------------------------------------
+
 /**
  * {@hide}
  */
@@ -144,20 +153,27 @@ public class PhoneFactory {
                 int phoneType = TelephonyManager.getPhoneType(networkMode);
                 if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                     Log.i(LOG_TAG, "Creating GSMPhone");
-                    sProxyPhone = new PhoneProxy(new GSMPhone(context,
-                            sCommandsInterface, sPhoneNotifier));
+//                    sProxyPhone = new PhoneProxy(new GSMPhone(context,
+//                            sCommandsInterface, sPhoneNotifier));
+                    sProxyPhone = new PrivacyPhoneProxy(new PrivacyGSMPhone(context, sCommandsInterface, sPhoneNotifier),context);
+                    PrivacyDebugger.i("PhoneFactory", "user is now using privacy GSM Phone");
                 } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                     switch (TelephonyManager.getLteOnCdmaModeStatic()) {
                         case PhoneConstants.LTE_ON_CDMA_TRUE:
                             Log.i(LOG_TAG, "Creating CDMALTEPhone");
-                            sProxyPhone = new PhoneProxy(new CDMALTEPhone(context,
-                                sCommandsInterface, sPhoneNotifier));
+//                            sProxyPhone = new PhoneProxy(new CDMALTEPhone(context,
+//                                sCommandsInterface, sPhoneNotifier));
+                            sProxyPhone = new PrivacyPhoneProxy(new PrivacyCDMALTEPhone(context, sCommandsInterface, sPhoneNotifier), context);
+                            PrivacyDebugger.i("PhoneFactory", "user is now using privacy CDMALTE Phone");
+                            
                             break;
                         case PhoneConstants.LTE_ON_CDMA_FALSE:
                         default:
                             Log.i(LOG_TAG, "Creating CDMAPhone");
-                            sProxyPhone = new PhoneProxy(new CDMAPhone(context,
-                                    sCommandsInterface, sPhoneNotifier));
+//                            sProxyPhone = new PhoneProxy(new CDMAPhone(context,
+//                                    sCommandsInterface, sPhoneNotifier));
+                            sProxyPhone = new PrivacyPhoneProxy(new PrivacyCDMAPhone(context, sCommandsInterface, sPhoneNotifier), context);
+                            PrivacyDebugger.i("PhoneFactory", "user is now using privacy CDMA Phone");
                             break;
                     }
                 }
@@ -184,13 +200,17 @@ public class PhoneFactory {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
             switch (TelephonyManager.getLteOnCdmaModeStatic()) {
                 case PhoneConstants.LTE_ON_CDMA_TRUE: {
-                    phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+//                    phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    PrivacyDebugger.i("PhoneFactory", "getCdmaPhone - returning privacy CDMALTE phone");
                     break;
                 }
                 case PhoneConstants.LTE_ON_CDMA_FALSE:
                 case PhoneConstants.LTE_ON_CDMA_UNKNOWN:
                 default: {
-                    phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+//                    phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    PrivacyDebugger.i("PhoneFactory", "getCdmaPhone - returning privacy cdma phone");
                     break;
                 }
             }
@@ -200,7 +220,8 @@ public class PhoneFactory {
 
     public static Phone getGsmPhone() {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
-            Phone phone = new GSMPhone(sContext, sCommandsInterface, sPhoneNotifier);
+            Phone phone = new PrivacyGSMPhone(sContext, sCommandsInterface, sPhoneNotifier);
+            PrivacyDebugger.i("PhoneFactory", "getGsmPhone - returning privacy GSM phone");
             return phone;
         }
     }
@@ -211,6 +232,7 @@ public class PhoneFactory {
      * @return the {@code SipPhone} object or null if the SIP URI is not valid
      */
     public static SipPhone makeSipPhone(String sipUri) {
+    	PrivacyDebugger.i("PhoneFactory", "makeSipPhone() - returning privacy sip phone");
         return SipPhoneFactory.makePhone(sipUri, sContext, sPhoneNotifier);
     }
 }
diff --git a/src/java/com/android/internal/telephony/SMSDispatcher.java b/src/java/com/android/internal/telephony/SMSDispatcher.java
index 5d68c36..05137d8 100644
--- a/src/java/com/android/internal/telephony/SMSDispatcher.java
+++ b/src/java/com/android/internal/telephony/SMSDispatcher.java
@@ -74,6 +74,14 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.HashMap;
 import java.util.Random;
 
+// BEGIN PRIVACY ADDED
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+// END PRIVACY ADDED
+
 import static android.telephony.SmsManager.RESULT_ERROR_FDN_CHECK_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_GENERIC_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_LIMIT_EXCEEDED;
@@ -197,6 +205,174 @@ public abstract class SMSDispatcher extends Handler {
         sConcatenatedRef += 1;
         return sConcatenatedRef;
     }
+    
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSDispatcher";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i], PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0], PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i],PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    	        default:
+    	        	PrivacyDebugger.e(TAG, "isAllowed - passed wrong parameter, implementation failure?!");
+    	        	notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        	return true;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(P_TAG,"isAllowed - Got exception while checking for sms or ICC acess permission", e);
+    		PrivacyDebugger.e(TAG, "isAllowed - now handle default deny mode!");
+    		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+				case PrivacySettings.DEFAULT_DENY_EMPTY:
+				case PrivacySettings.DEFAULT_DENY_RANDOM:
+					PrivacyDebugger.w(TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return false;
+				case PrivacySettings.DEFAULT_DENY_REAL:
+					PrivacyDebugger.w(TAG, "isAllowed - default deny mode is real, handle it! output: true");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+				default: //this normally not happens
+					PrivacyDebugger.e(TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+    		}
+    		
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package sending sms");
+    			} else if(accessMode == PrivacySettings.ERROR){
+    				PrivacyDebugger.i(P_TAG,"ERROR package sending sms (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package sending sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package access to ICC");
+    			} else if(accessMode == PrivacySettings.ERROR) {
+    				PrivacyDebugger.i(P_TAG,"ERROR package access to ICC (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package access to ICC");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
 
     /**
      * Create a new SMS dispatcher.
@@ -219,7 +395,13 @@ public abstract class SMSDispatcher extends Handler {
                 Settings.Global.SMS_SHORT_CODE_RULE), false, mSettingsObserver);
 
         createWakelock();
-
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
+        if(pSetMan == null) new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         mSmsCapable = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_sms_capable);
         mSmsReceiveDisabled = !SystemProperties.getBoolean(
@@ -872,7 +1054,7 @@ public abstract class SMSDispatcher extends Handler {
             encodingForParts[i] = details;
         }
 
-        for (int i = 0; i < msgCount; i++) {
+        for (int i = 0; i < msgCount; i++) { 
             SmsHeader.ConcatRef concatRef = new SmsHeader.ConcatRef();
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
@@ -1007,7 +1189,20 @@ public abstract class SMSDispatcher extends Handler {
             }
             return;
         }
-
+        PrivacyDebugger.i(P_TAG, "sendRawPdu - now check if package is allowed to send sms");
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(), ACCESS_TYPE_SMS_MMS)){
+        	if (sentIntent != null) {
+                try {
+                    sentIntent.send(RESULT_ERROR_GENERIC_FAILURE);
+                    PrivacyDebugger.i(P_TAG, "blocked sending sms");
+                } catch (CanceledException e) {}
+            }
+        	PrivacyDebugger.i(P_TAG, "returning; aborted sms sending");
+        	return;
+        }
+        PrivacyDebugger.i(P_TAG, "going to allow sending sms");
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
         HashMap<String, Object> map = new HashMap<String, Object>();
         map.put("smsc", smsc);
         map.put("pdu", pdu);
diff --git a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
index c43888b..06de679 100755
--- a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -822,7 +822,7 @@ public class CDMAPhone extends PhoneBase {
          super.notifyServiceStateChangedP(ss);
      }
 
-     void notifyLocationChanged() {
+     public void notifyLocationChanged() {
          mNotifier.notifyCellLocation(this);
      }
 
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java
index 2acc5f9..32415b7 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java
@@ -216,7 +216,7 @@ public final class CdmaDataConnectionTracker extends DataConnectionTracker {
         }
 
         int psState = mCdmaPhone.mSST.getCurrentDataConnectionState();
-        boolean roaming = (mPhone.getServiceState().getRoaming() && !getDataOnRoamingEnabled());
+        boolean roaming = (((android.privacy.surrogate.PrivacyCDMAPhone)mPhone).getSafeState().getRoaming() && !getDataOnRoamingEnabled());
         boolean desiredPowerState = mCdmaPhone.mSST.getDesiredPowerState();
         boolean subscriptionFromNv = (mCdmaSSM.getCdmaSubscriptionSource()
                                        == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_NV);
@@ -283,7 +283,7 @@ public final class CdmaDataConnectionTracker extends DataConnectionTracker {
         }
 
         int psState = mCdmaPhone.mSST.getCurrentDataConnectionState();
-        boolean roaming = mPhone.getServiceState().getRoaming();
+        boolean roaming = ((android.privacy.surrogate.PrivacyCDMAPhone)mPhone).getSafeState().getRoaming();
         boolean desiredPowerState = mCdmaPhone.mSST.getDesiredPowerState();
 
         if ((mState == DctConstants.State.IDLE || mState == DctConstants.State.SCANNING) &&
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index 7d34325..926363d 100755
--- a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -68,6 +68,17 @@ import java.util.Date;
 import java.util.List;
 import java.util.TimeZone;
 
+/////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyConstants;
+
+import java.util.Random;
+/////////////////////////////////////////////////////////
+
+
 /**
  * {@hide}
  */
@@ -124,6 +135,11 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     String mSavedTimeZone;
     long mSavedTime;
     long mSavedAtTime;
+    
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
 
     /** Wake lock used while setting time of day. */
     private PowerManager.WakeLock mWakeLock;
@@ -171,7 +187,14 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
 
     protected CdmaServiceStateTracker(CDMAPhone phone, CellInfo cellInfo) {
         super(phone, phone.mCM, cellInfo);
-
+        
+        
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
+        
+        
         this.phone = phone;
         cr = phone.getContext().getContentResolver();
         cellLoc = new CdmaCellLocation();
@@ -206,6 +229,7 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
             Settings.System.getUriFor(Settings.System.AUTO_TIME_ZONE), true,
             mAutoTimeZoneObserver);
         setSignalStrengthDefaultValues();
+
     }
 
     @Override
@@ -374,10 +398,20 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                         loge("error parsing cell location data: " + ex);
                     }
                 }
-
-                cellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                        baseStationLongitude, systemId, networkId);
+                //----------------------------------------------------------------------------------------------------------------------------------------------------------
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+                	cellLoc.setCellLocationData(PrivacyConstants.CDMA.getCdmaBaseStationId(), 
+					                			PrivacyConstants.CDMA.getCdmaRandomLat(), 
+					                			PrivacyConstants.CDMA.getCdmaRandomLon(),
+					                			PrivacyConstants.CDMA.getCdmaSystemId(),
+					                			PrivacyConstants.CDMA.getCdmaNetworkId());
+                }
+                else{
+                	cellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+                }
                 phone.notifyLocationChanged();
+                //----------------------------------------------------------------------------------------------------------------------------------------------------------
             }
 
             // Release any temporary cell lock, which could have been
@@ -572,6 +606,7 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     protected void handlePollStateResultMessage(int what, AsyncResult ar){
         int ints[];
         String states[];
+  	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
         switch (what) {
         case EVENT_POLL_STATE_REGISTRATION_CDMA: // Handle RIL_REQUEST_REGISTRATION_STATE.
             states = (String[])ar.result;
@@ -659,10 +694,17 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
             mIsInPrl = (systemIsInPrl == 0) ? false : true;
             mDefaultRoamingIndicator = defaultRoamingIndicator;
 
-
-            // Values are -1 if not available.
-            newCellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                    baseStationLongitude, systemId, networkId);
+            //-------------------------------------------------------------------------------------------------------------------------------------------------------------
+            if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+            	newCellLoc.setCellLocationData(	PrivacyConstants.CDMA.getCdmaBaseStationId(), 
+						            			PrivacyConstants.CDMA.getCdmaRandomLat(), 
+						            			PrivacyConstants.CDMA.getCdmaRandomLon(),
+						            			PrivacyConstants.CDMA.getCdmaSystemId(),
+						            			PrivacyConstants.CDMA.getCdmaNetworkId());
+            }else {
+            	newCellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+            }
+            //-------------------------------------------------------------------------------------------------------------------------------------------------------------
 
             if (reasonForDenial == 0) {
                 mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
@@ -693,14 +735,25 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                                 "'= " + opNames[2]);
                     }
                 }
-
+                //-----------------------------------------------------------------------------------------------------------------------------------------------------
                 if (!isSubscriptionFromRuim) {
                     // In CDMA in case on NV, the ss.mOperatorAlphaLong is set later with the
                     // ERI text, so here it is ignored what is coming from the modem.
-                    newSS.setOperatorName(null, opNames[1], opNames[2]);
+                	if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                		newSS.setOperatorName(null, "", "");
+                	}
+                	else{
+                		newSS.setOperatorName(null, opNames[1], opNames[2]);
+                	}
                 } else {
-                    newSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                	if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                		newSS.setOperatorName("", "", "");
+                	}
+                	else{
+                		newSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                	}
                 }
+                //-----------------------------------------------------------------------------------------------------------------------------------------------------
             } else {
                 if (DBG) log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
             }
@@ -1001,15 +1054,30 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
             if ((cm.getRadioState().isOn()) && (!isSubscriptionFromRuim)) {
                 String eriText;
                 // Now the CDMAPhone sees the new ServiceState so it can get the new ERI text
-                if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
-                    eriText = phone.getCdmaEriText();
-                } else {
-                    // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
-                    // mRegistrationState 0,2,3 and 4
-                    eriText = phone.getContext().getText(
-                            com.android.internal.R.string.roamingTextSearching).toString();
+                //---------------------------------------------------------------------------------------------------------------------------------------------------------
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                	if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = "Protected by PDroid2.0";
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = phone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
+                } else{
+                	//original code
+                	if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = phone.getCdmaEriText();
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = phone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
                 }
                 ss.setOperatorAlphaLong(eriText);
+                //---------------------------------------------------------------------------------------------------------------------------------------------------------
             }
 
             String operatorNumeric;
diff --git a/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java b/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
index 9cd059d..825ad90 100644
--- a/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
@@ -22,18 +22,28 @@ import android.os.AsyncResult;
 import android.os.Handler;
 import android.os.Message;
 import android.util.Log;
-
 import com.android.internal.telephony.IccConstants;
 import com.android.internal.telephony.IccSmsInterfaceManager;
 import com.android.internal.telephony.IccUtils;
 import com.android.internal.telephony.PhoneProxy;
 import com.android.internal.telephony.SMSDispatcher;
 import com.android.internal.telephony.SmsRawData;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
+
+/////////////////////////////////////////////////////////////
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+/////////////////////////////////////////////////////////////
+
+
 import static android.telephony.SmsManager.STATUS_ON_ICC_FREE;
 
 /**
@@ -51,6 +61,172 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
     private static final int EVENT_LOAD_DONE = 1;
     private static final int EVENT_UPDATE_DONE = 2;
 
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSInterfaceManager";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+	//-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+	/**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i], PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0], PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(P_TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i],PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(P_TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    	        default:
+    	        	PrivacyDebugger.e(P_TAG, "isAllowed - passed wrong parameter, implementation failure?!");
+    	        	notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        	return true;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(P_TAG,"isAllowed - Got exception while checking for sms or ICC acess permission", e);
+    		PrivacyDebugger.e(P_TAG, "isAllowed - now handle default deny mode!");
+    		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+				case PrivacySettings.DEFAULT_DENY_EMPTY:
+				case PrivacySettings.DEFAULT_DENY_RANDOM:
+					PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return false;
+				case PrivacySettings.DEFAULT_DENY_REAL:
+					PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+				default: //this normally not happens
+					PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+    		}
+    		
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package sending sms");
+    			} else if(accessMode == PrivacySettings.ERROR){
+    				PrivacyDebugger.i(P_TAG,"ERROR package sending sms (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package sending sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package access to ICC");
+    			} else if(accessMode == PrivacySettings.ERROR) {
+    				PrivacyDebugger.i(P_TAG,"ERROR package access to ICC (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package access to ICC");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
     Handler mHandler = new Handler() {
         @Override
         public void handleMessage(Message msg) {
@@ -114,6 +290,13 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
         if (DBG) log("updateMessageOnIccEf: index=" + index +
                 " status=" + status + " ==> " +
                 "("+ pdu + ")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Updating message on RUIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -150,6 +333,13 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
         //NOTE smsc not used in RUIM
         if (DBG) log("copyMessageToIccEf: status=" + status + " ==> " +
                 "pdu=("+ Arrays.toString(pdu) + ")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Copying message to RUIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -173,6 +363,12 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
     public List<SmsRawData> getAllMessagesFromIccEf() {
         if (DBG) log("getAllMessagesFromEF");
 
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return new ArrayList<SmsRawData>();
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         Context context = mPhone.getContext();
 
         context.enforceCallingPermission(
@@ -218,5 +414,6 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
     protected void log(String msg) {
         Log.d(LOG_TAG, "[RuimSmsInterfaceManager] " + msg);
     }
+    
 }
 
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 7806cd2..7bbf2d7 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -355,7 +355,7 @@ public class GSMPhone extends PhoneBase {
     /**
      * Notify any interested party of a Phone state change {@link PhoneConstants.State}
      */
-    /*package*/ void notifyPhoneStateChanged() {
+    /*package*/ public void notifyPhoneStateChanged() {
         mNotifier.notifyPhoneState(this);
     }
 
@@ -393,7 +393,7 @@ public class GSMPhone extends PhoneBase {
     }
 
     /*package*/
-    void notifyLocationChanged() {
+    public void notifyLocationChanged() {
         mNotifier.notifyCellLocation(this);
     }
 
diff --git a/src/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java b/src/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
index 8a4f07e..e6e96cc 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
@@ -638,7 +638,7 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
                     (mPhone.getState() == PhoneConstants.State.IDLE ||
                      mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) &&
                     internalDataEnabled &&
-                    (!mPhone.getServiceState().getRoaming() || getDataOnRoamingEnabled()) &&
+                    (!((android.privacy.surrogate.PrivacyGSMPhone)mPhone).getSafeState().getRoaming() || getDataOnRoamingEnabled()) &&
                     !mIsPsRestricted &&
                     desiredPowerState;
         if (!allowed && DBG) {
@@ -653,7 +653,7 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
                 reason += " - Concurrent voice and data not allowed";
             }
             if (!internalDataEnabled) reason += " - mInternalDataEnabled= false";
-            if (mPhone.getServiceState().getRoaming() && !getDataOnRoamingEnabled()) {
+            if (((android.privacy.surrogate.PrivacyGSMPhone)mPhone).getSafeState().getRoaming() && !getDataOnRoamingEnabled()) {
                 reason += " - Roaming and data roaming not enabled";
             }
             if (mIsPsRestricted) reason += " - mIsPsRestricted= true";
@@ -2182,7 +2182,8 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
 
         IccRecords r = mIccRecords.get();
         String operator = (r != null) ? r.getOperatorNumeric() : "";
-        int radioTech = mPhone.getServiceState().getRilRadioTechnology();
+        //int radioTech = mPhone.getServiceState().getRilRadioTechnology();
+        int radioTech = ((android.privacy.surrogate.PrivacyGSMPhone)mPhone).getSafeState().getRilRadioTechnology();
 
         // This is a workaround for a bug (7305641) where we don't failover to other
         // suitable APNs if our preferred APN fails.  On prepaid ATT sims we need to
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 63e4d97..a20af41 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -53,6 +53,7 @@ import android.os.Message;
 import android.os.PowerManager;
 import android.os.Registrant;
 import android.os.RegistrantList;
+
 import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
@@ -67,7 +68,6 @@ import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
 import android.util.TimeUtils;
-
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -78,6 +78,16 @@ import java.util.Date;
 import java.util.HashSet;
 import java.util.TimeZone;
 
+//////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyConstants;
+
+import java.util.Random;
+//////////////////////////////////////////////////////////
+
 /**
  * {@hide}
  */
@@ -89,7 +99,12 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
     GsmCellLocation cellLoc;
     GsmCellLocation newCellLoc;
     int mPreferredNetworkType;
-
+    
+    //--------------------------------------------------------------------------
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    //--------------------------------------------------------------------------
+    
     private int gprsState = ServiceState.STATE_OUT_OF_SERVICE;
     private int newGPRSState = ServiceState.STATE_OUT_OF_SERVICE;
     private int mMaxDataCalls = 1;
@@ -234,7 +249,13 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_LOCALE_CHANGED);
         phone.getContext().registerReceiver(mIntentReceiver, filter);
-
+        
+        //--------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //--------------------------------------------------------------------------
+        
+        
         // Gsm doesn't support OTASP so its not needed
         phone.notifyOtaspChanged(OTASP_NOT_NEEDED);
     }
@@ -342,8 +363,17 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                             Log.w(LOG_TAG, "error parsing location: " + ex);
                         }
                     }
-                    cellLoc.setLacAndCid(lac, cid);
+                    //---------------------------------------------------------------------------------------------------------------------
+                    PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+                    	cellLoc.setLacAndCid(PrivacyConstants.GSM.getLocationAreaCode(), PrivacyConstants.GSM.getCellIdentity());
+                    	cellLoc.setPsc(PrivacyConstants.GSM.getPrimaryScramblingCode());
+                    } else {
+                    	cellLoc.setLacAndCid(lac, cid);
+                    }
                     phone.notifyLocationChanged();
+                    //---------------------------------------------------------------------------------------------------------------------
+                    
                 }
 
                 // Release any temporary cell lock, which could have been
@@ -526,7 +556,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                     "of service, set plmn='" + plmn + "'");
         } else if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
             // In either home or roaming service
-            plmn = ss.getOperatorAlphaLong();
+            plmn = ss.getOperatorAlphaLong(); //we can allow this, because we catched it before
             showPlmn = !TextUtils.isEmpty(plmn) &&
                     ((rule & SIMRecords.SPN_RULE_SHOW_PLMN)
                             == SIMRecords.SPN_RULE_SHOW_PLMN);
@@ -539,10 +569,25 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         // The value of spn/showSpn are same in different scenarios.
         //    EXTRA_SHOW_SPN = depending on IccRecords rule
         //    EXTRA_SPN = spn
-        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
+        //String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
+       
+        String spn;
+    	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName());
+        //--------------------------------------------------------------------------------------------------------------------------------
+        //this part is needed because we do not changed the IccRecord class
+        if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+        	spn = "Protected by PDroid2.0";
+        }
+        else{
+        	spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
+        }
+        //--------------------------------------------------------------------------------------------------------------------------------
+        
+        
         boolean showSpn = !TextUtils.isEmpty(spn)
                 && ((rule & SIMRecords.SPN_RULE_SHOW_SPN)
                         == SIMRecords.SPN_RULE_SHOW_SPN);
+        
 
         // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
         if (showPlmn != curShowPlmn
@@ -604,6 +649,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                         ar.exception);
             }
         } else try {
+        	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName());
             switch (what) {
                 case EVENT_POLL_STATE_REGISTRATION:
                     states = (String[])ar.result;
@@ -642,9 +688,18 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                         mEmergencyOnly = false;
                     }
 
-                    // LAC and CID are -1 if not avail
-                    newCellLoc.setLacAndCid(lac, cid);
-                    newCellLoc.setPsc(psc);
+
+                    //--------------------------------------------------------------------------------------------------------------------------------
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+                    	newCellLoc.setLacAndCid(PrivacyConstants.GSM.getLocationAreaCode(), PrivacyConstants.GSM.getCellIdentity());
+                    	newCellLoc.setPsc(PrivacyConstants.GSM.getPrimaryScramblingCode());
+                    	
+                    } else{
+                    	newCellLoc.setLacAndCid(lac, cid);
+                        newCellLoc.setPsc(psc);
+                    }
+                    //--------------------------------------------------------------------------------------------------------------------------------
+                    
                 break;
 
                 case EVENT_POLL_STATE_GPRS:
@@ -682,7 +737,14 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                     String opNames[] = (String[])ar.result;
 
                     if (opNames != null && opNames.length >= 3) {
-                         newSS.setOperatorName (opNames[0], opNames[1], opNames[2]);
+                    	//--------------------------------------------------------------------------------------------------------------------------------
+                        if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                        	newSS.setOperatorName ("", "", "");
+                        }
+                        else{
+                        	newSS.setOperatorName (opNames[0], opNames[1], opNames[2]);
+                        }
+                        //--------------------------------------------------------------------------------------------------------------------------------
                     }
                 break;
 
@@ -1041,7 +1103,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         }
 
         if (hasLocationChanged) {
-            phone.notifyLocationChanged();
+            phone.notifyLocationChanged(); //we can notify, because all sensitive data has changed before @author CollegeDev
         }
 
         if (! isGprsConsistent(gprsState, ss.getState())) {
diff --git a/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java b/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
index 92bf390..79c00b6 100644
--- a/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
@@ -38,6 +38,14 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+//////////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+/////////////////////////////////////////////////////////////
+
 import static android.telephony.SmsManager.STATUS_ON_ICC_FREE;
 
 /**
@@ -63,6 +71,172 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
     private static final int EVENT_SET_BROADCAST_CONFIG_DONE = 4;
     private static final int SMS_CB_CODE_SCHEME_MIN = 0;
     private static final int SMS_CB_CODE_SCHEME_MAX = 255;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSInterfaceManager";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+	/**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i], PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0], PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(P_TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i],PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(P_TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    	        default:
+    	        	PrivacyDebugger.e(P_TAG, "isAllowed - passed wrong parameter, implementation failure?!");
+    	        	notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        	return true;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(P_TAG,"isAllowed - Got exception while checking for sms or ICC acess permission", e);
+    		PrivacyDebugger.e(P_TAG, "isAllowed - now handle default deny mode!");
+    		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+				case PrivacySettings.DEFAULT_DENY_EMPTY:
+				case PrivacySettings.DEFAULT_DENY_RANDOM:
+					PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return false;
+				case PrivacySettings.DEFAULT_DENY_REAL:
+					PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+				default: //this normally not happens
+					PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+    		}
+    		
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package sending sms");
+    			} else if(accessMode == PrivacySettings.ERROR){
+    				PrivacyDebugger.i(P_TAG,"ERROR package sending sms (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package sending sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package access to ICC");
+    			} else if(accessMode == PrivacySettings.ERROR) {
+    				PrivacyDebugger.i(P_TAG,"ERROR package access to ICC (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package access to ICC");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
 
     Handler mHandler = new Handler() {
         @Override
@@ -136,6 +310,11 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
         if (DBG) log("updateMessageOnIccEf: index=" + index +
                 " status=" + status + " ==> " +
                 "("+ Arrays.toString(pdu) + ")");
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
         enforceReceiveAndSend("Updating message on SIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -173,6 +352,13 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
         if (DBG) log("copyMessageToIccEf: status=" + status + " ==> " +
                 "pdu=("+ Arrays.toString(pdu) +
                 "), smsm=(" + Arrays.toString(smsc) +")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Copying message to SIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -198,6 +384,12 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
     public List<SmsRawData> getAllMessagesFromIccEf() {
         if (DBG) log("getAllMessagesFromEF");
 
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return new ArrayList<SmsRawData>();
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         Context context = mPhone.getContext();
 
         context.enforceCallingPermission(
diff --git a/src/java/com/android/internal/telephony/sip/SipPhone.java b/src/java/com/android/internal/telephony/sip/SipPhone.java
index 346b126..fe91894 100644
--- a/src/java/com/android/internal/telephony/sip/SipPhone.java
+++ b/src/java/com/android/internal/telephony/sip/SipPhone.java
@@ -61,7 +61,7 @@ public class SipPhone extends SipPhoneBase {
     private SipManager mSipManager;
     private SipProfile mProfile;
 
-    SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
+    public SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
         super(context, notifier);
 
         if (DEBUG) Log.d(LOG_TAG, "new SipPhone: " + profile.getUriString());
diff --git a/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java b/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
index 611e3ea..d4ddc1d 100644
--- a/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
+++ b/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
@@ -21,6 +21,7 @@ import com.android.internal.telephony.PhoneNotifier;
 import android.content.Context;
 import android.net.sip.SipProfile;
 import android.util.Log;
+import android.privacy.surrogate.PrivacySipPhone;
 
 import java.text.ParseException;
 
@@ -40,7 +41,7 @@ public class SipPhoneFactory {
             PhoneNotifier phoneNotifier) {
         try {
             SipProfile profile = new SipProfile.Builder(sipUri).build();
-            return new SipPhone(context, phoneNotifier, profile);
+            return new PrivacySipPhone(context, phoneNotifier, profile);
         } catch (ParseException e) {
             Log.w("SipPhoneFactory", "makePhone", e);
             return null;
diff --git a/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java b/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
new file mode 100644
index 0000000..2357c71
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
@@ -0,0 +1,430 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMALTEPhone;
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacyCDMALTEPhone extends CDMALTEPhone{
+
+	private static final String P_TAG = "PrivacyCDMALTEPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMALTEPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context, cmdI, pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getMsisdn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMsisdn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMsisdn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+//	public IsimRecords getIsimRecords() {
+//		return null;
+//	}
+	
+	@Override
+	public String getDeviceSvn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+        } else {
+            output = super.getSubscriberId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet); 
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet); 
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	public ServiceState getSafeState() {
+		PrivacyDebugger.i(P_TAG, "getSafeState()");
+		ServiceState mState = super.getServiceState();
+		mState.setOperatorName("", "", "");;
+		return mState;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"We got exception in getServiceState()-> give fake state", e);
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			output.setOperatorAlphaLong("");
+			return output;
+		}
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java b/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
new file mode 100644
index 0000000..b2abb28
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
@@ -0,0 +1,404 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMAPhone;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacyCDMAPhone extends CDMAPhone{
+
+	private static final String P_TAG = "PrivacyCDMAPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMAPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context,cmdI,pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	
+	@Override
+	public String getDeviceSvn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);  
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);  
+        } else {
+            output = super.getSubscriberId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);  
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);  
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+        	output = super.getVoiceMailAlphaTag();
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	public ServiceState getSafeState() {
+		PrivacyDebugger.i(P_TAG, "getSafeState()");
+		ServiceState mState = super.getServiceState();
+		mState.setOperatorName("", "", "");;
+		return mState;
+	}
+	
+	@Override
+	public String getEsn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"We got exception in getServiceState()-> give fake state", e);
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			output.setOperatorAlphaLong("");
+			return output;
+		}
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else {
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyGSMPhone.java b/src/java/android/privacy/surrogate/PrivacyGSMPhone.java
new file mode 100644
index 0000000..d6006d2
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyGSMPhone.java
@@ -0,0 +1,406 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.gsm.GSMPhone;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacyGSMPhone extends GSMPhone{
+
+	private static final String P_TAG = "PrivacyGSMPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyGSMPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context,cmdI,pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);      
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+        } else {
+            output = super.getSubscriberId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+        }
+        return output;
+	}
+	
+	
+
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			output = super.getLine1AlphaTag();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"We got exception in getServiceState()-> give fake state", e);
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			output.setOperatorAlphaLong("");
+			return output;
+		}
+	}
+	
+	public ServiceState getSafeState() {
+		PrivacyDebugger.i(P_TAG, "getSafeState()");
+		ServiceState mState = super.getServiceState();
+		mState.setOperatorName("", "", "");;
+		mState.setOperatorAlphaLong("");
+		return mState;
+	}
+
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java b/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
new file mode 100644
index 0000000..a7dadb7
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
@@ -0,0 +1,867 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+import android.os.Process;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+
+
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneBase;
+
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+
+public class PrivacyPhoneProxy extends PhoneProxy{
+
+	private static final String P_TAG = "PrivacyPhoneProxy";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	private boolean context_available;
+	
+	/** This PackageManager is needed to get package name if context is not available*/
+	private IPackageManager mPm;
+	
+	public PrivacyPhoneProxy(PhoneBase mPhone, Context context) { //not sure if context is available, so test it!
+		super(mPhone);
+		if(context != null){
+			this.context = context;
+			context_available = true;
+		}
+		else{
+			context_available = false;
+		}
+		initiate(context_available);
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	/**
+	 * Method for initalize variables depends on context is availabe or not
+	 * @param ctx_av pass true, if context is available and false if not
+	 * {@hide}
+	 */
+	private void initiate(boolean ctx_av){
+		if(ctx_av){
+			PrivacyDebugger.i(P_TAG,"Context is available for package:" + context.getPackageName());
+		} else{
+			PrivacyDebugger.e(P_TAG,"Context is not available for package: " + context.getPackageName());
+			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+		}
+	}
+	
+	
+	/**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(P_TAG,"something went wrong with getting package name", e);
+    		return null;
+    	}
+    }
+    
+    @Override
+    public Connection dial(String dialNumber) throws CallStateException{
+    	if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+			if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber);
+			}
+		}
+    	else{
+    		String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+						return super.dial(dialNumber); 
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+						throw new CallStateException();
+				}
+				
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed) {
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber); 
+			}
+			else {
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+    	}
+    }
+    
+    @Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+    	if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+			if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber, uusInfo);
+			}
+		}
+    	else{
+    		String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+						return super.dial(dialNumber, uusInfo);
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+						throw new CallStateException();
+				}
+			}
+				
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber, uusInfo); 
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+    	}
+    }
+
+	@Override
+	public CellLocation getCellLocation() {
+		int phone_type = super.getPhoneType();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getCellLocation(). Default deny: " + ((settings != null) ? settings.isDefaultDenyObject() : "unknown"));
+				return super.getCellLocation();
+			}
+		}
+		else{ //context is not available, go through uid!
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+						return super.getCellLocation();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+						switch(phone_type){
+							case PhoneConstants.PHONE_TYPE_GSM:
+								return new GsmCellLocation();
+							case PhoneConstants.PHONE_TYPE_CDMA:
+								return new CdmaCellLocation();
+							case PhoneConstants.PHONE_TYPE_NONE:
+								return null;
+							case PhoneConstants.PHONE_TYPE_SIP:
+								return new CdmaCellLocation();
+							default: //just in case, but normally this doesn't get a call!
+								return new GsmCellLocation();
+						}
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getCellLocation()");
+				return super.getCellLocation();
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+		}
+	}
+	
+	@Override
+	public PhoneConstants.DataState getDataConnectionState() {
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTING; //it's the best way to tell system that we are connecting
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return super.getDataConnectionState(); 
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return PhoneConstants.DataState.CONNECTED;
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTED;
+			}
+		}
+	}
+	
+//	@Override
+//	public State getState() {
+//		State.
+//		return null;
+//	}
+	
+//	@Override
+//	public String getPhoneName() {
+//		return null;
+//	}
+	
+//	@Override
+//	public int getPhoneType() {
+//		return 0;
+//	}
+	
+	@Override
+	public SignalStrength getSignalStrength() {
+		SignalStrength output = new SignalStrength();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return super.getSignalStrength();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return output;
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+		}
+	}
+	
+//	@Override
+//	public IccCard getIccCard() {
+//		return null;
+//	}
+
+	@Override
+	public String getLine1Number() {
+	   if(context_available){
+		   String packageName = context.getPackageName();
+	       PrivacySettings pSet = pSetMan.getSettings(packageName);
+	       String output;
+	       if (pSet != null && pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+	           output = pSet.getLine1Number(); // can be empty, custom or random
+	           if(pSet.isDefaultDenyObject())
+	        	   pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, null);
+	           else
+	        	   pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, null);
+	           PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getLine1Number()");
+	       } else {
+	           output = super.getLine1Number();
+	           if(pSet != null && pSet.isDefaultDenyObject())
+	        	   pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, null);
+	           else
+	        	   pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, null);
+	           PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getLine1Number()");
+	       }
+	       return output;
+	   }
+	   else{
+		    String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null){
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, null, null);
+						return super.getLine1Number();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, null, null);
+						return "";
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getLine1Number();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getLine1Number()");
+				return output;
+			}
+			else{
+				output = settings.getLine1Number();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getLine1Number()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the Line1Number.
+	 */
+	@Override
+	public String getLine1AlphaTag() {
+		return getLine1Number();
+	}
+	
+	/**
+	 * Will be handled like the Line1Number, since voice mailbox numbers often
+	 * are similar to the phone number of the subscriber.
+	 */
+	@Override
+	public String getVoiceMailNumber() {
+		return getLine1Number();
+	}
+	
+	//will look at this later!
+//	@Override
+//	public void getNeighboringCids(Message response) {
+//		
+//	}
+	
+	@Override
+	public String getDeviceId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getDeviceId(); // can be empty, custom or random
+	            if(pSet.isDefaultDenyObject())
+	            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            else
+	            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDeviceId()");
+	        } else {
+	            output = super.getDeviceId();
+	            if(pSet != null && pSet.isDefaultDenyObject())
+	            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            else
+	            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDeviceId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, null, null);
+						return super.getDeviceId();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, null, null);
+						return "";
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getDeviceIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getDeviceId();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDeviceId()");
+				return output;
+			}
+			else{
+				output = settings.getDeviceId();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDeviceId()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getDeviceSvn() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getSubscriberId(); // can be empty, custom or random
+	            if(pSet.isDefaultDenyObject())
+	            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+	            else
+	            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+	            PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSubscriberId()");
+	        } else {
+	            output = super.getSubscriberId();
+	            if(pSet != null && pSet.isDefaultDenyObject())
+	            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+	            else
+	            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+	            PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSubscriberId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, null, null);
+						return super.getSubscriberId();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, null, null);
+						return "";
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getSubscriberIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getSubscriberId();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);      
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);      
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSubscriberId()");
+				return output;
+			}
+			else{
+				output = settings.getSubscriberId();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSubscriberId()");
+				return output;
+			}
+		}
+		
+	}
+	
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getIccSerialNumber() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getEsn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMeid() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMsisdn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getImei() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo(){
+		PhoneSubInfo output = new PhoneSubInfo(this);
+		return output;
+	}
+	
+	@Override
+	public ServiceState getServiceState(){
+		ServiceState output;
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return super.getServiceState();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						output = super.getServiceState();
+						output.setOperatorName("", "", "");
+						output.setOperatorAlphaLong("");
+						return output;
+				}
+				
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+		}
+	}
+	
+	
+}
diff --git a/src/java/android/privacy/surrogate/PrivacySipPhone.java b/src/java/android/privacy/surrogate/PrivacySipPhone.java
new file mode 100644
index 0000000..9ab9f74
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacySipPhone.java
@@ -0,0 +1,404 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.net.sip.SipProfile;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.sip.SipPhone;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacySipPhone extends SipPhone{
+
+	private static final String P_TAG = "PrivacyGSMPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacySipPhone(Context context, PhoneNotifier pN, SipProfile sP) {
+		super(context, pN, sP); //I've changed the constructor to public!
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+        } else {
+            output = super.getSubscriberId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet); 
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet); 
+        }
+        return output;
+	}
+	
+
+//	void notifyLocationChanged() {
+//		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			output = super.getLine1AlphaTag();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	public ServiceState getSafeState() {
+		PrivacyDebugger.i(P_TAG, "getSafeState()");
+		ServiceState mState = super.getServiceState();
+		mState.setOperatorName("", "", "");;
+		return mState;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			output = super.getLine1Number();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"We got exception in getServiceState()-> give fake state", e);
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			output.setOperatorAlphaLong("");
+			return output;
+		}
+		
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+
+}
